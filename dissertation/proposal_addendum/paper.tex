\documentclass[letterpaper]{article}

\usepackage{cite}
\usepackage{pstricks}
\usepackage{url}

\title{Proposal Addendum}
\author{Justin R. Wilson}
\date{}

\begin{document}
\maketitle

\section{Implementation:  Translation vs. Library}

The goal of the implementation is to allow developers to encode reactive systems using reactive components.
The first approach is to specify reactive components directly by designing a new programming language.
This approach necessitates the development of a translator that takes reactive components and produces a form that can ultimately be executed.
A viable approach to the translator may be to output another programming language such as C or Java.
The second approach is to specify reactive components indirectly in an existing programming language via a library.

Both approaches rest on a set of semantic checks that enforce the atomicity and determinism of transitions and composed transitions.
The atomicity and determinism guarantees are needed to avoid subtle data races and therefore are a necessary part of any implementation.
These checks are performed at compile-time in the translation approach and either at load-time or run-time in the library approach.

In addition to the semantic checks and run-time library of the library approach, the translation approach requires the development of a translator.
In the library approach, the burden of translation is shifted to the developer as reactive components and transitions must be defined programmatically.

The main issue with the library approach is the difference in semantics between the host language and the semantics of reactive components.
Lee describes how introducing concurrency via library significantly alters the semantics of the language~\cite{lee2006problem}.
Most likely, the host language will be sequential imperative programming language like C or Java.
Reactive components on the other hand are based on non-deterministic sequencing.
If the target of the translator is a language like C or Java, then both approaches must ultimately express reactive components using the semantics of a sequential imperative language.
The advantage of the translator approach is that the introduction of reactive component semantics is automatic and not subject to programmer error.

\section{Evaluation}

The goal of the evaluation is to understand the impact of the guarantees and features of reactive components as they relate to design and implementation.
The general idea of the evaluation is to 1) identify a set of representative systems, 2) identify a set of models (and platforms) used to design and implement reactive systems, 3) describe the guarantees and features provided by each model, 4) implement each application for each model, and 5) describe the impact of the guarantees and features on the design and implementation.

The main characteristic of candidate reactive systems is the existence of two or more independently evolving and interacting units of composition.
One of the units may be an abstract external environment like the physical environment (embedded systems) or user (interactive systems).
Similarly, the units of composition may be other reactive systems (distributed systems).
Thus, candidate reactive systems should come from embedded systems, interactive systems, and distributed systems.

Concurrency appears in two forms in reactive systems.
First, units of composition in a reactive system are inherently concurrent.
Units of composition may be introduce out of necessity, i.e., nodes in a distributed systems, or for performance.
Second, concurrency may be used to increase the performance of the state transitions in individual units of composition.
This type of concurrency is the subject of parallel programming and is orthogonal to the proposed work.
The focus of this evaluation is the first form where units of composition are introduced via decomposition.

Unfortunately, there is not a canonical set of applications for comparing models for reactive systems.
I believe that a set of exemplars should be drawn from well-studied problems in theory, software engineering, and practice.
Three candidates may be, for example, the Dining Philosophers Problem, Conway's Problem, and the Transmission Control Protocol.
The key idea is that any platform for reactive systems should be able to implement most if not all of the example problems.

The Models for reactive systems include threads with locks or atomic transactions, 





\paragraph{Scope.}
We outline a number of models of computation to define the characteristics of representative reactive systems.
First, we exclude transformational programs which either transform a finite input sequence into a finite output sequence or fail to terminate (the halting problem).
Such computations are essentially self-contained and deterministic meaning that the same input always produces the same output.
(A transformational program may be non-deterministic in the sense that it has to explore a number of possible computations to finish.
This is referred to as ``don't care'' non-determinism~\cite{atomic_transactions}.)

Concurrency is often introduced as a way to accelerate inherently transformational computations and is the subject of parallel programming.
Parallel programming techniques are either synchronous, e.g., SIMD, pipelining, etc. or asynchronous, e.g., streaming, tasks (fork/join), etc.
Asynchronous parallel computations are often partitioned to avoid updating shared state so as to avoid data races and non-determinism.
(This kind of non-determinism is referred to as ``don't know'' non-determinism~\cite{atomic_transactions}.)
Locks and atomic transactions may also be used to avoid data races.






This idea has been explored in a variety of ways and at a variety of granularities, e.g., SIMD, pipelining, streaming, task-level parallelism, etc.

For example, single instruction multiple data (SIMD) parallelism applies the same operation to different inputs at the same time.
Pipelining and streaming divide a complex computation into a series of concurrently executing stages.
Task-level parallelism can be used to apply the same computation to parallel data items or to execute unrelated computations.
The fork/join model of computation is a 

SIMD, pipelining, and streaming are synchronous 

Applying the same operationData-level parallelism If the same operationIndependence in Data-level parallelism means that 







Manna and Pnueli define a reactive systems as one that has ``ongoing interactions with its environment.''
A candidate system then consists of at least two units corresponding to the reactive system and its environment.



Unfortunately, there is not a canonical set of applications used to compare models for reactive systems.




The first part of the evaluation is to identify a set of representative reactive systems.
What is a representative reactive system?



The first part of the evaluation is to identify other models of reactive systems for comparison.
Candidates include threads with locks and/or atomic transactions, , threads with atomic transactions, 

A similar analysis should be pe
The evaluation consists of three dimensions.
The first dimension consists of models for reactive systems including reactive components.



Model
  - Guarantees
  - Features
  - Techniques




%% \input abstract.tex

%% \input introduction.tex

%% \input background.tex

%% \input model.tex

%% \input implementation.tex

%% \input evaluation.tex

%% \input conclusion.tex

\bibliographystyle{plain}
\bibliography{paper}{}

\end{document}
