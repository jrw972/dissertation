\chapter{Reactive Component Model}
\label{model}

In this chapter, we present a new model for composing and decomposing reactive programs via \emph{reactive components}.
The model is biased toward practical software development even as it enforces properties based in formal methods.
Consequently, the model favors utility, practicality, flexibility, and ease of implementation.
Unlike UNITY in which composition is not property-preserving, the composition of reactive components is property-preserving which facilitates hierarchical and modular reasoning.
Unlike I/O Automata in which transitions have limited depth, a transition among reactive components may access and cascade to an arbitrary number of other components, which permits decomposition to an arbitrary depth and degree.

%% \paragraph{Formal models and software engineering.}
%% I claim that most of the software that is ``put into production'' will never be proved formally correct.
%% This is a function of economics since modeling and constructing proofs is a labor-intensive process that can only be justified for safety or mission critical software.
%% However, I would argue that the development and application of formal models are critical to software engineering.
%% To illustrate, consider \emph{structured programming}~\cite{dahl1972structured}.
%% Structured programming assumes an abstract machine that executes programs that are restricted to a small set of well-defined control structures and assignment statements.
%% A program written in this form can be reasoned about directly from the text by formulating a Hoare-triple for each statement.
%% Structured programming opened the door for \emph{structured programming languages} which are also based on well-defined control structures and evaluation semantics.
%% Thus, while very few programmers will prove their structured programs correct, all of them informally use structured programming when they are fixing a bug revealed by a unit test or analyzing a core dump in a debugger.
%% Structured programming languages reduced the accidental complexity associated with writing the same program in assembly language.

%% The realm of reactive programs is waiting for a similar reduction in accidental complexity.
%% Taking a hint from structured programming, I believe two things are required.
%% First, we must write reactive programs against an easy-to-reason-about abstract machine instead of low-level interfaces like atomic instructions and thread libraries.
%% Second, we must restrict the form of reactive programs so that they can be reasoned about from the text.
%% I hope the proposed model of reactive systems is a step toward toward this goal.

\section{Features of the Model}

\input{shapes}

%% left active pull port
%% x, y, width, height, label
\def\lapull[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=lightgray] (#1,#2) -- ++(${#4*.5}*(-1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(-1,0)$) -- cycle;
  \node (#5) at (#1,#2) {};
  \node (#6) at ($(#1,#2) + {#3 - .5 * #4}*(1,0)$) {};
  \node [right, align=left] at (#1,#2) {#7};
}

%% left active push port
%% x, y, width, height, label
\def\lapush[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=white] ($(#1,#2) + {#4*.5}*(-1,0)$) -- ++(${#4*.5}*(1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(-1,0)$) -- cycle;
  \node (#5) at ($(#1,#2) - .5*#4*(1,0)$) {};
  \node (#6) at ($(#1,#2) + {#3}*(1,0)$) {};
  \node [right, align=left] at (#1,#2) {#7};
}

%% left passive pull port
%% x, y, width, height, label
\def\lppull[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=lightgray] ($(#1,#2) + {#4*.5}*(-1,0)$) -- ++(${#4*.5}*(1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(-1,0)$) -- cycle;
  \node (#5) at ($(#1,#2) - .5*#4*(1,0)$) {};
  \node (#6) at ($(#1,#2) + {#3}*(1,0)$) {};
  \node [right, align=left] at (#1,#2) {#7};
}

%% left passive push port
%% x, y, width, height, label
\def\lppush[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=white] (#1,#2) -- ++(${#4*.5}*(-1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(-1,0)$) -- cycle;
  \node (#5) at (#1,#2) {};
  \node (#6) at ($(#1,#2) + {#3 - .5*#4}*(1,0)$) {};
  \node [right, align=left] at (#1,#2) {#7};
}

%% right passive pull port
%% x, y, width, height, label
\def\rppull[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=lightgray] ($(#1,#2) + {#4*.5}*(1,0)$) -- ++(${#4*.5}*(-1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(-1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(1,0)$) -- cycle;
  \node (#5) at ($(#1,#2) + {#4*.5}*(1,0)$) {};
  \node (#6) at ($(#1,#2) + {#3}*(-1,0)$) {};
  \node [left] at (#1,#2) {#7};
}

%% right active push port
%% x, y, width, height, label
\def\rapush[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=white] ($(#1,#2) + {#4*.5}*(1,0)$) -- ++(${#4*.5}*(-1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(-1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(1,0)$) -- cycle;
  \node (#5) at ($(#1,#2) + {#4*.5}*(1,0)$) {};
  \node (#6) at ($(#1,#2) + {#3}*(-1,0)$) {};
  \node [left] at (#1,#2) {#7};
}

%% right passive push port
%% x, y, width, height, label
\def\rppush[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=white] (#1,#2) -- ++(${#4*.5}*(1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(-1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(1,0)$) -- cycle;
  \node (#5) at (#1,#2) {};
  \node (#6) at ($(#1,#2) + {#3 - .5*#4}*(-1,0)$) {};
  \node [left] at (#1,#2) {#7};
}

%% right active pull port
%% x, y, width, height, label
\def\rapull[#1,#2,#3,#4,#5,#6]#7{
  \draw [fill=lightgray] (#1,#2) -- ++(${#4*.5}*(1,0) + {#4*.5}*(0,-1)$) -- ++($#3*(-1,0)$) -- ++($#4*(0,1)$) -- ++($#3*(1,0)$) -- cycle;
  \node (#5) at (#1,#2) {};
  \node (#6) at ($(#1,#2) + {#3 - .5*#4}*(-1,0)$) {};
  \node [left] at (#1,#2) {#7};
}

\begin{figure}[H]
\centering
\resizebox{\textwidth}{!}{%
\begingroup
\fontsize{10pt}{12pt}\selectfont
\input{model_diagram}
\endgroup
}%
\caption{Features of a reactive component\label{reactive_component}}
\end{figure}

Figure~\ref{reactive_component} shows the major features of a reactive component.
As in other state-based formal models like UNITY~\cite{chandy1989parallel} and I/O Automata~\cite{nancy1996distributed}, the core of a reactive component in this model is a set of \emph{state variables} and a set of atomic \emph{transitions} that manipulate those state variables.
When reasoning about a system, behavior is expressed as propositions over the state variables where the propositions are derived from the transitions.

%% The contribution that this work makes to existing state-based formal models of reactive systems is a combination of interface elements and composition semantics that allow reactive programs to be composed in a principled way.

The reactive component model defines interface elements and composition semantics that allow reactive programs to be composed in a principled way.
For example, an \emph{active push port} allows a transition in one component to be linked to a transition in another component such that the resulting combined transition is atomic.
Active push ports allow reactive components to publicize their behavior.
An active push port may be \emph{bound} to and conditionally \emph{activate} zero or more \emph{passive push ports}.
A passive push port names the corresponding transition that will be executed when the passive push port is activated.
This combination of passive push port and transition is called a \emph{reaction} because it reacts to a transition in another component.

The atomic linkage of a transition in one component to a transition in another component through the push port mechanism allows the properties of each component to be related to one another and more complex systems to be constructed by composing simpler systems.
Transitions that are not executed via a passive push port are executed by the scheduler.
A transition of this kind may be governed by a Boolean expression called a \emph{precondition}.
The combination of a precondition and transition is called an \emph{action} because it is a voluntary transition under the control of the containing component.

An \emph{active pull port} represents an immutable external data dependency.
The component may \emph{call} an active pull port to yield a value required in a transition.
Active pull ports must be bound to a \emph{passive pull port} which resembles a function returning one or more values.
Associated with a passive pull port is an expression that may interrogate the state of the corresponding component or call other pull ports.
The combination of a passive pull port and an expression is called a \emph{getter}.
Where push ports allow components to publicize their behavior, pull ports allow components to safely publicize their internal state for use by other components.

Composition in the reactive component model has two main features.
The first is recursive encapsulation where a state variable in one component may represent an instance of another reactive component.
The second is the ability to bind push ports and pull ports through an \emph{explicit} set of \emph{bindings}.
The decision to use an explicit set of bindings (as opposed to implicit named-based matching) is more in keeping with the goals and techniques of practical software development, since it facilitates the use of software developed under different naming conventions, i.e., third-party software.
A third minor feature called \emph{exporting} is the ability of an encapsulating component to adopt interface elements of its sub-components without defining complimentary ports and transitions that do nothing but forward an activation or call.
The ability to publicize behavior and state and the ability to assemble well-defined behavior from existing behaviors in a straight-forward and flexible way are thus defining characteristics of the reactive component model.

\begin{figure}
\centering
\resizebox{\textwidth}{!}{%
\begingroup
\fontsize{10pt}{12pt}\selectfont
\begin{tikzpicture}
\draw (0,6.5) rectangle (5,10);
\node[below] at (2.5,10) {Web Server};
\rapull[5,9,3.4,.5,ex1a,ignore]{verify(HttpHeader)};
\rapush[5,8,3.6,.5,ex2a,ignore]{request(HttpRequest)};
\rppush[5,7,4.2,.5,ex3a,ignore]{respond(HttpResponse)};

\draw(6,2.5) rectangle (11,10);
\node[below] at (8.5,10) {Application Logic};
\lppull[6,9,3.4,.5,ex1b,ignore]{verify(HttpHeader)};
\lppush[6,8,3.8,.5,ex2b,ignore]{request(HttpRequest)};
\lapush[6,7,3.9,.5,ex3b,ignore]{respond(HttpResponse)};

\rapush[11,6,3.5,.5,ex4a,ignore]{request(DBRequest)};
\rppush[11,5,4.1,.5,ex5a,ignore]{respond(DBResponse)};

\rapush[11,3,2.4,.5,ex6a,ignore]{log(Message)};

\draw (12,4.5) rectangle (17,7);
\node[below] at (14.5,7) {Database};
\lppush[12,6,3.7,.5,ex4b,ignore]{request(DBRequest)};
\lapush[12,5,3.8,.5,ex5b,ignore]{respond(DBResponse)};

\draw (12,2.5) rectangle (17,4);
\node[below] at (14.5,4) {Logging Service};
\lppush[12,3,2.5,.5,ex6b,ignore]{log(Message)};

\draw (ex1a.center) -- (ex1b.center);
\draw (ex2a.center) -- (ex2b.center);
\draw (ex3a.center) -- (ex3b.center);
\draw (ex4a.center) -- (ex4b.center);
\draw (ex5a.center) -- (ex5b.center);
\draw (ex6a.center) -- (ex6b.center);

\end{tikzpicture}
\endgroup
}%
\caption{Diagram of a web application built using reactive components\label{web_server}}
\end{figure}

To demonstrate the utility of component interfaces and explicit support for property-preserving composition, we now present an illustrative design for a web application using reactive components, as is shown in Figure~\ref{web_server}.
The web application consists of five reactive components.
The first is an unnamed top-level component representing the complete application.
This component has four sub-components representing a web server, the application logic, a database, and a logging service.
The ports of the application logic component have been bound to the corresponding ports in the web server, database, and logging service components.
The interface of a component, which consists of its ports, provides insight into the behavior of the component.
For example, based on the interface of the web server component we may expect it to 1)~verify incoming HTTP requests\footnote{A production web server may verify that the requested HTTP method can be applied to the given URI, that content length limits are respected, that content types are supported, etc.}, 2)~pass on valid HTTP requests to the application, and 3)~accept HTTP responses from the application.

Figure~\ref{web_server} also demonstrates how reactive programs can be constructed by composing reactive components, so that a developer may focus on the application logic and use existing components for the web server, database, and logging service.
Furthermore, one can imagine developing three stateless components surrounding the application logic that do nothing but translate messages between application specific message types and the generic types required by the web server, database, and logging service.
The application logic, then, is completely isolated from the surrounding libraries and may be tested by providing mock components for the web server, database, and logging service.
The application logic itself has a well-defined interface and could be reused, say, by implementing a graphical front-end to drive the application instead of a web service.

\subsection{State Variables}
Part of the internal core of a reactive component is a set of state variables, which are the subject of the propositions that demonstrate the behavior of the system.
The state variables are manipulated by the assignment statements that constitute the transitions.
As in other formal models, the types of the state variables may be selected to make writing proofs easier.
%% That is, the state variables have mathematically friendly types like integers, sets, and lists.
However, implementations of the reactive component model must provide a concrete type system that allows the state variables to be realized on a given machine.
For example, the \rcgo{} language for reactive components presented in Chapter~\ref{language} of this dissertation uses the type system of Go to define the types of state variables.
The type of a state variable also may be a reactive component type, which facilitates recursive encapsulation.
For modeling purposes, state variables typically have \emph{value semantics} to avoid reasoning about references and aliasing.
However, and as a practical concession, we will introduce pointers for building arbitrary linked data structures (since we advocate an imperative state-based implementation) and discuss issues raised by introducing pointers into the reactive component model in Chapter~\ref{language}.

\subsection{Atomic State Transitions}
The rest of the internal core of a reactive component is a set of atomic state transitions that manipulate the state variables.
A precise definition of the atomicity of state transitions will be deferred to the subsequent sections on composition (Section~\ref{composition}) and execution (Section~\ref{execution}).
State variables and state transitions are private, meaning that transitions can only refer to the state variables of the associated reactive component and a transition in one reactive component can only be linked to a transition in another component through the composition mechanisms.
Thus, all initialization and updates to state variables can be determined by examining the transitions of the corresponding component.
The encapsulation of state variables contribute to composition being \emph{compositional}.
All properties established from the transitions of a component will continue to hold as the component participates in composition since the set of transitions that affect the state variables is fixed.
State transitions must be deterministic meaning that the next value of every state variable is uniquely and well defined.
State transitions defined by a sequence of simple assignments are implicitly deterministic.
However, special care must be take to ensure that state transitions are deterministic when described using parallel assignment statements as the same variable may appear on the left-hand-side and be assigned two different values~\cite{chandy1989parallel}.
As described in Sections~\ref{composition} and \ref{execution}, composition links transitions using parallel assignment which creates an opportunity for non-deterministic state transitions.
The problem of non-deterministic state transitions arising from composition is explored in Section~\ref{propcomp}.

The reactive component model presented in this chapter does not prescribe a specific language for encoding state transitions.
The language used depends on the goals and tastes of the one developing or analyzing the model.
For example, expressing transitions using the programming language of UNITY~\cite{chandy1989parallel} may allow the modeler to extract proofs from the text, a major goal of UNITY.
The approach used by I/O Automata~\cite{nancy1996distributed} is to specify the condition established by each transition.
As with state variables, we present a language that uses the statements and expressions of the Go programming language to encode state transitions in Chapter~\ref{language}.
This furthers our goal of making reactive components approachable by a general software engineering audience.
%% from Dr. Gill
%% which aims to allow models to be incorporated directly into standard software environments.
%% This isn't accurate.  Compatibility with existing software is not the goal nor should it be a goal as existing software is based on threads which cannot reasonably be integrated with reactive components.

\subsection{Actions, Reactions, Push Ports, Bindings, and Composition}
\label{composition}
A state transition is either part of an action or a reaction.
An \emph{action} is a state transition whose execution is under the control of the component to which it belongs.
The action is guarded by a \emph{precondition} that is guaranteed to be true the instant before the action is executed.
The precondition is a Boolean expression that determines if the action is \emph{enabled} or \emph{disabled}.
If the precondition is absent, it is assumed to be true.

A \emph{reaction} is a state transition whose execution is under the control of another action or reaction.
Thus, we require a mechanism for linking a reaction to an action or another reaction.
To do this, we introduce the notion of a \emph{push port}.
A push port is a typed interaction point consisting of an active side that conditionally \emph{activates} the port and provides arguments to the port, and a passive side that \emph{reacts} to the port and may access the arguments provided by the active side.
A reaction, therefore, is the combination of a passive push port and a state transition.

A \emph{binding} is a declaration that associates an active push port in one component with a reaction in another component.
The transition associated with the reaction is executed atomically with the transition that activates the active push port.
Composition in the reactive component model is achieved by declaring sub-components (recursive encapsulation) and linking transitions via binding.

\subsection{Transactions}

A \emph{transaction} is a compound and concrete state transition formed by expanding the activations in an instance/action pair, subject to the bindings in a system.
The instance and action that define a transaction are called the \emph{root} of the transaction.
A transaction is enabled/disabled if its root action is enabled/disabled.
Given the root instance and action, we may enumerate the active push ports that may be activated by the transition of the action.
Note that the activation of a push port is conditional, being under the control of the transition.
The push ports, in turn, activate reactions in particular component instances.
The transitions associated with the reactions may activate other push ports and so on.
This analysis can be repeated to discover all of the reactions that are linked to the root action.
The result is a \emph{transaction graph} which is a directed acyclic graph $G = (N,E)$.
Each node $n \in N$ is a pair $(i, x)$ where $i$ is a component instance and $x$ is either an action, reaction, activation, or push port.
Each edge $e \in E$ corresponds to a causal relationship between an action/reaction and an activation, an activation and a push port, or a push port and a reaction.
The edges between actions/reactions and activations indicate that the action/reaction \emph{may} execute the activation, as they may be conditionally executed.
The edges between activations and push ports and between push ports and reactions indicate that the implied push port or reaction \emph{will} be executed if the upstream activation is executed.

\subsection{Execution}
\label{execution}
We adopt the common practice of modeling concurrency with non-deterministically executed atomic actions as is done in UNITY~\cite{chandy1989parallel}, I/O Automata~\cite{nancy1996distributed}, and the Actor Model~\cite{agha1985actors}.
The execution of transactions is performed by a \emph{scheduler}.
The scheduler executes one transaction at a time, thus, each transaction is \emph{atomic} with respect to all other transactions.
A transaction is \emph{enabled} if its precondition is true.
When executing a transaction, the scheduler first evaluates the precondition and then executes the body of the transaction if the transaction is enabled.
Thus, executing an enabled transaction \emph{may} result in a state change while executing a disabled transaction \emph{never} causes a state change.
The scheduler is \emph{fair} meaning that each transaction is executed an infinite number of times.
The system may reach a \emph{fixed point} where all transactions are disabled.
The order in which transactions are executed is not determined, thus, execution is \emph{non-deterministic}.

We divide a state transition into two phases called the \emph{immutable phase} and the \emph{mutable phase}.
Logically, a transition assigns values to a set of state variables.
This can be modeled as a parallel assignment statement with a left-hand side (LHS) consisting of a list of state variables and a right-hand side (RHS) consisting of a list of expressions that provide the next value for each corresponding state variable.
The immutable phase corresponds to the computation of the RHS in a state transition.
The mutable phase corresponds to the update of the values on the LHS with the values on the RHS.
When transitions are linked with composition, we must relate the mutable and immutable phase in one state transition to the mutable and immutable phases of the other transitions in the transaction.
Let $A$ be a transition (action) and $R$ be a transition (reaction) that is activated by $A$.
Let $A_I$ be the immutable phase of $A$, $A_M$ be the mutable phase of $A$, $R_I$ be the immutable phase of $R$, and $R_M$ be the mutable phase of $R$.
For the sake of argument, assume that $A_I$ reads variables that are written in $R_M$ and that $R_I$ reads variables that are written in $A_M$.
We require that $A_I$ be evaluated before $A_M$, $R_I$ be evaluated before $R_M$, and $A_I$ be evaluated before $R_I$ since activation is conditional.
This leaves three possible sequences:
\begin{itemize}
\item $A_I A_M R_I R_M$.  In this sequence, a variable is first updated in $A_M$ and then the updated value is read in $R_I$.  The issue with this interpretation is that it does not compose well.  Ideally, we would like to be able to rewrite the transition as a single transition consisting of a single immutable phase and mutable phase.
\item $A_I R_I A_M R_M$ and $A_I R_I R_M A_M$.  These sequences resolve the issue with the first sequence by providing a clear immutable phase ($A_I R_I$) and mutable phase ($A_M R_M$ and $R_M A_M$).
\end{itemize}
Thus, with respect to transactions, all immutable phases (which includes all push port activations) are performed before all mutable phases.

\section{Example:  Clock System}
To illustrate the behavior of reactive components under this model, we rewrite the \emph{Clock automaton} example in \cite{nancy1996distributed} using reactive components.
The Clock automaton consists of a free-running counter and flag used to implement a request-response protocol.
Our Clock component is defined in Figure~\ref{clock_component}.
The state variables are identified with \verb+var+ and their initial values are provided.
The component contains a reaction named \verb+request+ for receiving requests to sample the current value of the counter.
The component also contains an active push port named \verb+clock+ for communicating the sampled value of the counter.
The \verb+Clock+ action is conditioned on the flag variable (which indicates that a request has been made) which when it executes resets the flag and communicates the value of \verb+counter+ by activating the \verb+clock+ port.
The \verb+Tick+ action increments the free-running counter.
The absence of a precondition means this action is always enabled.
A simple client for the Clock component that perpetually requests the current count is shown in Figure~\ref{client_component}.

\begin{figure}
\begin{verbatim}
component Clock {
  var int counter (0)
  var bool flag (false)
  push clock(int t)

  reaction request() flag := true

  Clock: flag -> flag := false activates clock(counter)

  Tick: counter := counter + 1
}
\end{verbatim}
\caption{Definition of the Clock component of the Clock System}
\label{clock_component}
\end{figure}

\begin{figure}
\begin{verbatim}
component Client {
  var bool flag (false)
  push request()

  Request: !flag -> flag := true activates request()

  reaction clock(int t) flag := false || /* do something with t */
}
\end{verbatim}
\caption{Definition of the Client of the Clock System}
\label{client_component}
\end{figure}

In isolation, a Clock component will increment its counter forever and a Client component will make a request and then stop.
In order to make the two components work together, we must compose them.
Figure~\ref{system_component} shows a System component that instantiates a Clock component and a Client component and binds the corresponding push ports in each instance.
In the composed system, the client's \verb+Request+ action will be executed activating the \verb+request+ port which in turn causes the \verb+request+ reaction in the clock to be executed.
Figure~\ref{request_transaction} shows the transaction graph for the \verb+Request+ action.
Eventually, the clock's \verb+Response+ action will be executed activating the \verb+clock+ port which in turn causes the \verb+clock+ reaction in the client to be executed with the current value of the clock's counter.
Figure~\ref{clock_transaction} shows the transaction graph for the \verb+Clock+ action.
In between these actions, the \verb+Tick+ action of the clock is incrementing the counter.

\begin{figure}
\begin{verbatim}
component System {
  var Clock clock
  var Client client

  bind {
    client.request -> clock.request
    clock.clock -> client.clock
  }
}
\end{verbatim}
\caption{Definition of the System component of the Clock System}
\label{system_component}
\end{figure}

\begin{figure}
\centering
%%\resizebox{\textwidth}{!}{%
\begingroup
\fontsize{10pt}{12pt}\selectfont
\begin{tikzpicture}[
    arrowstyle/.style={draw, -stealth},
    edge from parent/.style={draw, -stealth},
    reaction/.style={rectangle, draw, rounded corners=1mm, text width=2.5cm,
        text centered, anchor=north},
    activation/.style={rectangle, draw, rounded corners=1mm, dashed, text width=2.5cm,
        text centered, anchor=north},
    push/.style={rectangle, draw, rounded corners=1mm, dotted, text width=2.5cm,
        text centered, anchor=north},
    level 1/.style={sibling distance=7.0cm},
    level 2/.style={sibling distance=4.0cm},
    level 3/.style={sibling distance=3.0cm},
    level distance=0.5cm, growth parent anchor=south
]
\node (Action) [reaction] {client.Request}
  child {
    node (Activation01) [activation] {client.(activation in Request)}
    child {
      node (Push01) [push] {client.request}
      child {
        node (Reaction01) [reaction] {clock.request}
      }
    }
  }
;
\end{tikzpicture}
\endgroup
%%}%
\cprotect\caption{Transaction diagram for the \verb+client.Request+ action of the Clock System}
\label{request_transaction}
\end{figure}

\begin{figure}
\centering
%%\resizebox{\textwidth}{!}{%
\begingroup
\fontsize{10pt}{12pt}\selectfont
\begin{tikzpicture}[
    arrowstyle/.style={draw, -stealth},
    edge from parent/.style={draw, -stealth},
    reaction/.style={rectangle, draw, rounded corners=1mm, text width=2.5cm,
        text centered, anchor=north},
    activation/.style={rectangle, draw, rounded corners=1mm, dashed, text width=2.5cm,
        text centered, anchor=north},
    push/.style={rectangle, draw, rounded corners=1mm, dotted, text width=2.5cm,
        text centered, anchor=north},
    level 1/.style={sibling distance=7.0cm},
    level 2/.style={sibling distance=4.0cm},
    level 3/.style={sibling distance=3.0cm},
    level distance=0.5cm, growth parent anchor=south
]
\node (Action) [reaction] {clock.Clock}
  child {
    node (Activation01) [activation] {clock.(activation in Clock)}
    child {
      node (Push01) [push] {clock.clock}
      child {
        node (Reaction01) [reaction] {client.clock}
      }
    }
  }
;
\end{tikzpicture}
\endgroup
%%}%
\cprotect\caption{Transaction diagram for the \verb+clock.Clock+ action of the Clock System}
\label{clock_transaction}
\end{figure}

\section{Properties of Composition}
\label{propcomp}
In this section, we examine various features related to reactive components and composition.
Substitutional equivalence for reactive components is demonstrated by outlining a procedure for in-lining sub-components.
Hazards of composition, namely, non-deterministic state transitions resulting from conflicting and recursive composition, are identified and a means of detecting them is proposed.
The issue of decomposition is considered and \emph{pull ports} are introduced as a mechanism for decomposition.

\begin{figure}
\begin{verbatim}
component System {
  /* Substitution of clock component. */
  var int clock_counter (0)
  var bool clock_flag (false)
  push clock_clock(int t)

  reaction clock_request() clock_flag := true

  clock_Clock: clock_flag -> clock_flag := false activates clock_clock(clock_counter)

  clock_Tick: clock_counter := clock_counter + 1

  /* Substitution of client component. */
  var bool client_flag (false)
  push client_request()

  client_Request: !client_flag -> client_flag := true activates client_request()

  reaction client_clock(int t) client_flag := false || /* do something with t */

  bind {
    client_request -> clock_request
    clock_clock -> client_clock
  }
}
\end{verbatim}
\caption[Substitution of sub-components for the Clock System]{Substitution of state variables, ports, actions, and reactions for the sub-components of the System component of the Clock System}
\label{se1}
\end{figure}

\begin{figure}
\begin{verbatim}
component System {
  var int clock_counter (0)
  var bool clock_flag (false)
  var bool client_flag (false)
  push clock_clock(int t)
  push client_request()

  clock_Clock: clock_flag -> clock_flag, client_flag :=
    false, false activates clock_clock(clock_counter) ||
    /* do something with clock_counter */

  client_Request: !client_flag -> client_flag, clock_flag :=
    true, true activates client_request()

  clock_Tick: clock_counter := clock_counter + 1
}
\end{verbatim}
\caption[Simplification of expanded System component of the Clock System]{Simplifications of ports, bindings, and transitions in the expanded System component of the Clock System}
\label{se2}
\end{figure}

\subsection{Substitutional Equivalence}
\label{substitutional_equivalence}
For reactive components, substitutional equivalence means that a sub-component can be replaced with its definition and the result is a well-defined entity in the model.
To this end, a procedure for substituting the definition of a sub-component involves 1) renaming and adding all state variables, ports, actions, and reactions to the parent component and 2) simplifying bindings by substituting the transitions associated with a reaction into the action or reaction that activates the reaction in question.

To illustrate, Figure~\ref{se1} shows the result of substituting state variables, ports, actions, and reactions into the System component of Figure~\ref{system_component}.
Identifiers in the sub-components have been prefixed with the name of the sub-component instance to avoid name clashes.
For example, the \verb+request+ reaction in the \verb+clock+ sub-component has been renamed to \verb+clock_request+.
Figure~\ref{se2} shows the result of simplifying bindings and state transitions.
Note that the push ports have been retained for subsequent composition, i.e., the System component may be a component in a larger system.
The result is a reactive component whose ``size'' in terms of state variables, actions, and reactions is the sum of the sizes  of its constituent components.
Substituting the definition of the Clock component and Client components into the System component confirms the intuition that the flag variable in the client and flag variable in the clock are the same since 1) initially they have the same value and 2) they take on the same value in every state transition.

\subsection{Determinism and Composition}
\label{determinism}

\begin{figure}
\centering
%%\resizebox{\textwidth}{!}{%
\begingroup
\fontsize{10pt}{12pt}\selectfont
\begin{tikzpicture}[
    arrowstyle/.style={draw, -stealth},
    edge from parent/.style={draw, -stealth},
    reaction/.style={rectangle, draw, rounded corners=1mm, text width=2.5cm,
        text centered, anchor=north},
    activation/.style={rectangle, draw, rounded corners=1mm, dashed, text width=2.5cm,
        text centered, anchor=north},
    push/.style={rectangle, draw, rounded corners=1mm, dotted, text width=2.5cm,
        text centered, anchor=north},
    level 1/.style={sibling distance=7.0cm},
    level 2/.style={sibling distance=4.0cm},
    level 3/.style={sibling distance=3.0cm},
    level distance=0.5cm, growth parent anchor=south
]
\node (Action) [reaction] {A.set}
  child {
    node (Activation01) [activation] {A.(activation in set)}
    child {
      node (Push01) [push] {A.setPush1}
      child {
        node (Reaction01) [reaction] {B.setTrue}
      }
    }
    child {
      node (Push02) [push] {A.setPush2}
      child {
        node (Reaction02) [reaction] {B.setFalse}
      }
    }
  }
;
\end{tikzpicture}
\endgroup
%%}%
\caption{Transaction diagram for a non-deterministic transaction}
\label{ndt}
\end{figure}

The result of composing two well-defined reactive components may yield a system that is non-deterministic.
The two ``hazards'' that must be avoided are non-deterministic assignment to state variables and recursively activated reactions.
Non-deterministic assignment results when the next value for a state variable is not well defined due to the inclusion of two or more transitions in a transaction that operate on the state variable.
To illustrate, consider the transaction depicted in Figure~\ref{ndt}.
The set action of component A has a single activation that activates both the setPush1 and setPush2 push ports.
The setPush1 port is bound to the setTrue reaction of component B while the setPush2 port is bound to the setFalse reaction of the same component B.
Suppose that the setTrue reaction sets a flag to true while the setFalse reaction sets the same flag to false.
The transaction is non-deterministic because the value of the flag after the (A,set) transaction may either be true or false.
An offending pair of transitions may appear anywhere in a transaction graph given that arbitrary transaction graphs may be constructed through composition.
If the underlying language used to define transitions admits pointers, dynamic memory, if statements, and loops (i.e., is Turing-complete), then the problem of determining if two transitions operate on the same state variable is undecidable in general~\cite{Landi:1992:USA:161494.161501, Ramalingam:1994:UA:186025.186041}.
For a transaction graph $G$, instances $i_1$ and $i_2$, and actions/reactions $t_1$ and $t_2$, a necessary (but not sufficient) condition for non-deterministic assignment $\mathit{NDA}$ from composition is $\mathit{NDA}(G): \exists (i_1, t_1), (i_2, t_2) \in G.N, i_1 = i_2, t_1 \ne t_2$ which says that the transaction must contain two different transitions involving the same component instance.

A recursively activated transition occurs when the transaction graph has a cycle.
The execution of such a transaction may result in well-defined next values for all state variables assuming that 1)~the recursion is bounded and 2)~the parameters passed to every reaction result in identical computations.
A transaction may be analyzed like a traditional transformational program since it has finite input, a finite output, and should terminate.
The first problem, then, is a thinly disguised version of the halting problem since it asks if a computation (the transaction) expressed in a Turing-complete language terminates (has bounded recursion)~\cite{Turing01011937, davis1958computability}.
A bounded recursion means that the execution of the transaction will generate a bounded number of activations $A$.
For each activation $a \in A$, we must determine what state is updated by $a$.
If the language is Turing-complete, then this problem is undecidable in general~\cite{Landi:1992:USA:161494.161501, Ramalingam:1994:UA:186025.186041}.
For state variables that are updated by more than one activation, we must then show that each activation sets the state variable to the exact same next state.
If we treat each activation as a program, then we require a function that determines if two (arbitrary) programs compute the same function, which is again, undecidable in general~\cite{Rice:53}.

The difficulty of detecting composition that results in non-deterministic assignments suggests that these problems are best checked by a machine.
That is, an implementation of reactive components may prevent non-deterministic assignment by checking that $\mathit{NDA}(G)$ is false for all transaction graphs in the system.
Similarly, an implementation may check for recursive activation by checking for cycles in transaction graphs.
Both of these approaches are used by the implementation described in Section~\ref{sound_composition}.

\subsection{Decomposition, Getters, and Pull Ports}
\label{decomposition}
Substitutional equivalence implies that the process of substituting the definition of a sub-component into a parent component may be reversed and that sub-components may be ``factored out'' of an existing component, e.g., for reuse with other components.
%% One motivation for extracting sub-components is to support the software engineering practice of refactoring where common code is extracted so that it can be reused in various places.

Another motivation for decomposition is potentially increased performance through parallelism.
Recall that true concurrency in reactive components is modeled as the serial and non-deterministic execution of atomic actions.
Two transactions can be safely executed concurrently if it can be shown that the state variables involved in each transaction are disjoint.
As was previously mentioned, making this determination is undecidable for Turing-complete languages in the general case.
However, the problem becomes decidable if the component instance is used as a proxy for its constituent state variables.
Let $\mathit{rw}: t \to \{ \mathit{Read}, \mathit{Write} \}$ be a function that maps a transition to a value indicating that variables are read-only during the transition or written in some way.
Two instance/transition pairs are independent ($\mathit{indp}$) if either the instances are different or at most one of the transitions writes to the variables of the instance:
\begin{equation}
\mathit{indp}((i_1, t_1), (i_2, t_2)): i_1 \ne i_2 \lor \lnot (\mathit{rw}(t_1) = \mathit{Write} \land \mathit{rw}(t_2) = \mathit{Write})
\end{equation}
Two transaction graphs are independent if all of their nodes are independent $\mathit{indp}(G_1, G_2) = \forall (i_1, t_1) \in G_1.N, (i_2, t_2) \in G_2.N \; \mathit{indp}((i_1, t_1), (i_2, t_2))$.
The significance of the preceding analysis is that the determination about what actions can be executed concurrently becomes machine checkable due to the strong guarantee that state variables belonging to an instance can only be modified by the transitions of that instance.

To illustrate the mechanisms required for decomposition, we will factor out a Counter component from the Clock component of Figure~\ref{clock_component} and then rewrite the Clock component using the Counter component.
Upon inspection, the \verb+Tick+ action and \verb+request+ reaction can be executed concurrently since the state variables involved in each transition are disjoint.
Figure~\ref{counter_component} shows the Counter component which consists of a \verb+counter+ state variable.
The \verb+Tick+ action can be moved to the Counter component without complication.
The \verb+Clock+ action of the Clock component \emph{reads} the value of \verb+counter+ which suggests that a mechanism for accessing the state variables in a component is required.
Thus, we introduce the notion of a \emph{getter} method which can be called on a component to produce a value that may be derived from its state variables.
In the Counter component, the \verb+getCounter+ getter returns the current value of the counter.
A getter is not allowed to modify the state of a component and may only be invoked in the immutable phase.
These semantics preserve the strict separation of immutable phase and mutable phase.
When analyzing composition, a getter is treated like a transition that reads the state variable of the corresponding instance.
Figure~\ref{factored_clock_component} shows the Clock component rewritten to use a Counter sub-component and a getter.

\begin{figure}
\begin{verbatim}
component Counter {
  var int counter (0)

  Tick: counter := counter + 1

  getCounter() int {
    return counter
  }
}
\end{verbatim}
\caption{Definition of the Counter component of the Factored Clock System}
\label{counter_component}
\end{figure}

\begin{figure}
\begin{verbatim}
component Clock {
  var Counter c
  var bool flag (false)
  push clock(int t)

  reaction request() flag := true

  Clock: flag -> flag := false activates clock(c.getCounter())
}
\end{verbatim}
\caption{Definition of the Clock component of the Factored Clock System}
\label{factored_clock_component}
\end{figure}

The logic associated with the \verb+flag+ state variable represents a generic request-response protocol except for the call to \verb+c.getCounter()+.
To indirect the call to \verb+c.getCounter()+ we introduce the notion of a \emph{pull port}.
A pull port represents an external value dependency.
A component can demand a value from the pull port in the immutable phase.
Like push ports, pull ports have an active and passive side.
The active side represents the caller and the passive side represents the callee.
Getters are sufficient to realize the passive side of a pull port.
Every active pull port must be bound to exactly one passive pull port via composition.
Figure~\ref{request_response_component} shows a component that implements the request-response protocol using a pull port \verb+getValue+.
Figure~\ref{factored2_clock_component} shows the Clock component written in terms of the Counter and RequestResponse components.
An \verb+export+ directive allows reactions, getters, and ports in sub-components to be available in the interface of the encapsulating component.

\begin{figure}
\begin{verbatim}
component RequestResponse {
  var bool flag (false)
  pull getValue() int
  push response(int t)

  reaction request() flag := true

  Response: flag -> flag := false activates response(getValue())
}
\end{verbatim}
\caption{Definition of the RequestResponse component of the Factored Clock System}
\label{request_response_component}
\end{figure}

\begin{figure}
\begin{verbatim}
component Clock {
  var Counter c
  var RequestResponse rr

  bind {
    c.getCounter -> rr.getValue
  }

  export rr.request as request
  export rr.response as clock
}
\end{verbatim}
\caption{Definition of the Clock component of the Factored Clock System (fully-factored)}
\label{factored2_clock_component}
\end{figure}

Pull ports are subject to a hazard of composition similar to the recursive activation hazard of push ports.
A cycle in the graph of composed pull ports is equivalent to a recursively defined function.
The recursion may be bounded but this is undecidable in the general case.
Consequently, an implementation may reject recursively defined getters and pull ports.

\section{Summary}
In this chapter, we have presented the reactive component model for reactive programs.
A reactive component consists of a set of state variables and transitions that are private to the component.
The interface of a reactive component consists of push ports and reactions, which allow a component to trigger a transition in another component, and pull ports and getters, which allow a component to access the state of another component.
The external or visible behavior of a reactive component can be traced through its interface, specifically its push ports.
The internal details of a component can often be abstracted away to permit reasoning about the behavior of a composed system at various levels of detail.
Composition is achieved through recursive encapsulation (sub-components) and explicit port binding and satisfies the requirements for principled composition set forth in Section~\ref{challenges}.
As demonstrated in Section~\ref{substitutional_equivalence}, the definitions of sub-components can be substituted into the containing component resulting in an equivalent system (substitutional equivalence).
Similarly, sub-components may be ``factored out'' by using pull ports and getters to safely access the state of the sub-components.

The private nature of state variables and transitions causes properties established from the text of a component to be preserved through composition.
Composition links transitions to form an atomic transaction that allows the properties of one component to be related to another component.
When the sub-components of a component are protected from further composition, the properties derived from their interactions are preserved as the parent component is composed.
Property-preserving composition is essential for reasoning about systems in a hierarchical and/or modular fashion.

The result of composing reactive components is either well-defined due to the atomic nature of transactions or illegal due to the composition hazards of recursive transactions and non-deterministic state transitions.
Analysis of these hazards at the state variable level is impossible due to the undecidable nature of their sub-problems.
This suggests that implementations may restrict composition to prevent the conditions necessary for recursive transactions and non-deterministic state transitions.
The main concession is allowing a component instance to proxy for its state variables.
The problem of detecting recursive transactions, then, can be posed as the problem of detecting cycles in a directed graph.
Similarly, the problem of detecting potentially non-deterministic state transitions is reduced to a set membership problem.
Valid systems that fail the check for non-deterministic state transitions using component instance proxies can be refactored by decomposing  the offending components.
