type Element struct
{
  value @heap uint;
  next @Element;
};

type Queue struct
{
  head @Element;
  tail @@Element;
};

func (this @Queue) Push (v @heap uint)
{
  if this.head == nil
    {
      this.tail = this.head&;
    };

  var e @Element;
  e = new Element;
  e.value = v;
  this.tail@ = e;
  this.tail = e.next&;
}

func (this @Queue) Pop ()
{
  this.head = this.head.next;
  if this.head == nil
    {
      this.tail = this.head&;
    };
}

func (this @Queue const) Empty () bool
{
  return this.head == nil;
}

func (this @Queue const) Front () @heap uint const
{
  return this.head.value;
}

type Channel component
{
  queue Queue;
  receive port (message @heap uint foreign);
};

reaction (this @Channel const) send (message @heap uint foreign)
{
  var x @heap uint;
  x = move (message);
  trigger
  {
    this.queue.Push (x);
  };
}

action (this @Channel const) (this.queue.Empty ()!)
{
  trigger receive (this.queue.Front ())
    {
      this.queue.Pop ();
    };
}

type System component
{
  channel Channel;
  send_count uint;
  send port (message @heap uint foreign);
};

func (this @System) Initially ()
{ }

action (this @System const) (this.send_count != 100u)
{
  var x @heap uint;
  x = new heap uint;
  change (x, y @uint)
  {
    y@ = this.send_count;
  };
  trigger send (x)
  {
    println `Sent `, this.send_count;
    this.send_count++;
  };
}

reaction (this @System const) receive (message @heap uint foreign)
{
  var x @uint;
  x = merge (message);
  println `Received `, x@;
}

bind (this @System) {
  this.send -> this.channel.send;
  this.channel.receive -> this.receive;
}

instance s System Initially;
